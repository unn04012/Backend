### 웹 어댑터

- 외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨 일을 해야 할지 알려준다.
- `Controller layer`

**역할**

- HTTP 요청을 객체로 매핑
- 권한 검사
- 입력을 유스케이스의 입력 모델로매핑
- 유스케이스 호출
- 응답 반환
- 에러를 호출자에게 보여줄 메시지로 변환한다.
- 도메인 로직을 두지 않는다.

**어댑터와 유스케이스 사이에 간접 계층인 포트를 넣어야 하는 이유**

- 포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나고 있는지 알 수 있다.

```tsx
여기서 핵심은 어떠한 도메인 로직도 수행하지 않는 어댑터를 만드는 것을 염두에 둬야 한다.
```

- 이러게 할 경우 웹 어댑터를 다른 어댑터로 쉽게 교체할 수 있다.
- 여러 작은 클래스들을 만들 경우 더 파악하기 쉽고, 더 테스트하기 쉬우며, 동시 작업을 지원한다.

### 영속성 어뎁터

- db와 통신할 책임을 가진 클래스(구현체 클래스)

**구조**

```tsx
서비스 → 포트 ← 영속성 어댑터
```

- 포트라는 간접적인 계층을 둘 경우, 도메인 로직을 만들기 위해 영속성 문제에 신경쓰지 않아도 된다.
- 영속성 코드를 리팰토링 하더라고 코어 코드를 변경하는 결과로 이어지지 않는다.

### 영속성 어댑터의 책임

1. 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 전송 후 출력 반환

**핵심**

- 영속성 어댑터의 입력모델이 영속성 어댑터 내부에 있는 것이 아닌 애플리케이션 코어에 있다.
- 즉, 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다.
- 마찬가지로 출력 모델이 영속성 어댑터가 아니라 애플리케이션 코어에 위치하는 것이다.

### 인터페이스 분리 원칙

- 클라이언트가 오로지 자신을 필요로 하는 메서드만 알면 되도록 넗은 인터페이스를 특화된 인터페이스로 분리해야 한다.
- 즉, 하나의 구현체인 영속성 어댑터가 여러개의 인터페이스를 구현하는 방식으로 갈 수 있는 것이다.

```tsx
기존에는 프로젝트 작성시 하나의 레포지토리 interface에 모든 쿼리 항목들을 정의하였는데 반대로 좁은포트(
를 만드는 것은 괜찮은 것 같다) 오히려 서비스에서 모킹하기도 쉬울 것 같다
하지만 포트 하나 당 하나의 메서드를 적용하는 것은 오버엔지니어링, 즉, 오히려 관리할 수 있는 항목이 더 많아지는 
측면이 없지 않아 생긴다.
오히려, 서비스 로직에 더 많은 의존성이 생길 수 있지 않을까라는 생각이 든다.
하지만 서비스도 유즈케이스 별로 분리되면 괜찮을까롣 생각이들지만서도.. 이런식으로 구현해본적은 없다.

나는 포트당 메서드별로 나누지는 않되, 도메인 엔티티별로 나눌 수 있지 않을까라는 생각이 든다.
꼭 도메인 엔티티가 아니더라도 loader즉, 조인과 같은 개념의로 쓰는 레포티토리, 통계 레포지토리 같은 
개념들은 분리된 인터페이스로 적용하는 건 오히려 유지보수와 모킹에도 용이하다고 생각이든다.

```

결론은 다음과 같은 항목들은 시험해볼 수 있다.

하나의 구현체이지만 여러 개의 인터페이스별로 즉, 여러 포트별로 나누어서 적용하는건 오히려 가독성과 유지보수성에는 좋아 보인다.

나는 서비스 layer에서까지 단위 테스트를 적용하고 싶지 않다. 해당 레이어는 여러 컴포넌트들을 호출만 하지 핵심 비즈니스 로직은 도메인 엔티티나 하위 클래스로 설계를 해두었기 때문이다.

즉, 서비스 레이어는 통합 테스팅에 더 용이하게 작성을 한 것이다. (트랜잭션 관리 또는 여러 컴포넌트들간의 호출만 담당하기 때문에)

하위 클래스에서도 결국에는 레토지토리 layer를 쓸수밖에 없는 상황이 있기 때문에 해당 클래스에만 사용하는 레포지토리를 별도의 인터페이스로 나누는건 너무 좋아 보이는 방법이라고 생각이 든다..!
