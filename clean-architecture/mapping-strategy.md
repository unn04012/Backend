### 매핑하지 않기 전략

`하나의 도메인 모델을 공유한다`

장점

- 간단한 CRUD 애플리케이션일 경우 매핑할 필요가 없다.
- 즉, 모든 계층이 같은 정보를 필요로 한다면 오히려 매핑할 필요가 없어 생산성또한 증가할 수 있다.

단점

- 특정 계층에서 필요로 하는 요구사항을 모두 다뤄야 하기 때문에 `단일 책임 원칙`을 위반한다.
- 결국, 유지보수성이 증가한다.

### 양방향 매핑 전략

`각 계층이 전용 모델을 가진 전략`

장점

- 웹이나 영속성 관심사로 오염되지 않은 깨끗한 도메인 모델로 이어진다.
- 매핑 책임이 명확해 도메인 로직에 집중할 수 있다.

단점

- 너무 많은 보일러 플레이트 코드
- 도메인 모델이 계층 경계를 넘어서서 통신하고 있다.
    
    → 바깥쪽 계층의 요구에 따른 변경에 취약해진다.
    

### 완전 매핑 전략

`각 연산마다 별도의 입출력 모델을 사용한다.`

- 애플리케이션과 웹 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 빛을 발한다.
- 애플리케이션 계층과 영속성 계층은 사용하지 않는 것이 좋다.
    
    → 매핑 오버헤드가 증가한다.
    

### 단방향 매핑 전략

`모든 계층의 모델들이 같은 인터페이스를 구현한다.`

현재 프로젝트를 진행중인 전략은 `완전 매핑 전략`을 이용하고 있다. 책에서 나온 것처럼 웹 계층과 애플리케이션

웹 계층에서 메서드별 DTO를 각각 정의하기 떄문에(해당 클래스에서 validation까지 진행함) 두 계층에서 좋은 것 같다. 하지만 책에서 나온 것처럼 영속성 계층에서는 매핑 오버헤드가 발생하는 문제가 있었다.

영속성 계층에서도 완전 매핑 전략을 이용하는 것이 매핑 오버헤드라는 단점이 있지만 장점도 존재한다고 생각한다.

- 명시적이다.
- 그에 따른 가독성 증가

하지만, 연산이 추가될 때마다 매핑을 추가로 해야 하기 때문에 여간 귀찮은일이 아니다.

그래서 도메인 엔티티를 통해서만 진행한다. 하지만 예상하지 못한 필드도 변경될 수 있는 문제가 있다.

그래서 불변값과 변경할 수 있는 값들을 명확히 나눠서 update하도록 만들어봤다.

```tsx
export class DomainEntity {
  private readonly _id: number;
  private readonly _userId: string;
  private readonly _accountId: string;
  private readonly _regDate: Date;

  private _analysisDate: Nullable<Date>;
  private _status: Status;
  private _beforeId: number;
  private _afterId: number; 
  
  public updateForSave() { 
    return {
      id: this._id,
      beforeId: this._beforeId,
      afterId: this._afterId,
      status: this._status,
      analysisDate: this._analysisDate,
    };
  }
```

- 영속성 계층에서는 해당 도메인 엔티티를 가지고 변경가능성 있는 것들만 변경하도록 해보았다.
- id를 반환하는 이유는 typeorm의 `save` method를 이용하기 때문에 예외적으로 PK값을 넘겨준다.

`즉, 양방향 매핑 전략과 단방향 매핑 전략을 같이 이용하는 전략이 된다고 생각된다.`
